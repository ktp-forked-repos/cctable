
\section{Introduction}
\seclab{intro}

Tabling, or memoisation, is a well known technique for speeding up computations
by saving and reusing the results of earlier subcomputations instead of repeating
them. In other contexts, this strategy is called `dynamic programming', and, when
used effectively, can reduce algorithms with exponential time complexity to polynomial
or linear complexity.

We assume some familiarity with Prolog. In the program listings that follow, the code
has been rendered using typographic features not available in the real source; in particular
\verb|:-| is rendered as ":-", \verb|->| as "->", \verb|-->| as "-->", and variables with numeric suffixes
are rendered with subscripts. In addition, Prolog lambda expressions are typeset, for example,
as "\X^Y^Goal", but coded as \verb|\X^Y^Goal|.

\section{Background}

Memoisation
\cite{Michie1968}.
Tabling, Earley deduction, OLDT and SLG
\cite{Earley1970,Warren1975,PereiraWarren1980,Porter1986,TamakiSato1986}.
Delimited continuations \cite{Felleisen1988,DanvyFilinski1990,Filinski1999,Shan2004,KiselyovShan2009,Kiselyov2012}.
Memoising functional parser combinators \cite{Norvig1991,Lindgren1994,Johnson1995}.
Continuations in Prolog \cite{TarauNeumerkel1994,TarauDahl1998,Neumerkel1995,SchrijversDemoenDesouter2013,DesouterVan-DoorenSchrijvers2015}.

\section{Multi-prompt delimited control in Prolog}

Continuation passing style and continuation-based control operators have been well studied in the
context of lambda calculus and functional programming \citep{SussmanSteele1975}.
The idea of delimited continuations was arrived at independently by \cite{Felleisen1988} and
\cite{DanvyFilinski1990}. Multiple, first class, independently addressible prompts were introduced
by \cite{DyvbigJonesSabry2005} in their monadic Haskell implementation, which was recast
as an OCaml library to be used in `direct style' (i.e. using neither monadic nor explicit continuation 
passing styles) by \cite{Kiselyov2012}. The basic operation of multi-prompt delimited
control can be described in terms of the |new_prompt|, |push_prompt| and |shift| operators provided by
this library, which have the following OCaml types (in which Greek letters denote type variables):
\begin{ocamlet}
	new_prompt	: unit -> 'a prompt
	push_prompt	: 'a prompt -> (unit -> 'a) -> 'a
	shift        : 'a prompt -> (('b -> 'a) -> 'a) -> 'b
\end{ocamlet}
Given a prompt |p| with answer type |'a|, created using |new_prompt|, a thunk |f : unit -> 'a| is evaluated
in a context delimited by the prompt |p| by calling |push_prompt p f|, which plays the role of |reset| in 
\citepos{DanvyFilinski1990} framework.
Calls to |push_prompt|, using the same or differing prompts, can be nested arbitrarily.
If, inside |f|, there is a call to |shift p h|, the
continuation out to the nearest instance of |push_prompt p| is captured as a function |k : 'b -> 'a|, and passed to the handler
|h|, whose return value is then returned from the enclosing |push_prompt|. The captured continuation includes an implict
enclosing |push_prompt p|, which hides any further calls to |shift p| it may contain, and means that, from the outside,
it looks like a pure function, which can be called zero, once, or many times. During a call to the handler |h|,
the original outer prompt stays in place, so that any calls to |shift p| made by the handler do not
escape the original delimited context. Other frameworks provide a different set of control operators, but
they are all closely related and expressible in terms of each other \citep{Shan2004}.

\citepos{SchrijversDemoenDesouter2013} implementation of delimited continuations for Prolog provides two
primitives, "reset/3" and "shift/1". If a Prolog goal is called as "reset(Goal, Ball, Cont)", with both
"Ball" and "Cont" unbound, then "Goal" is executed inside a delimited context. If it completes
successfully, then "Cont" is unified with "0".  If "shift/1" is called inside "Goal", then "Cont" is bound
to a callable representation of the continuation from that point out to the enclosing "reset", "Ball"
is bound to the argument of "shift/1", and control is passed to the code following the "reset".
The continuation "Cont" can be called subsequently, resuming the interrupted execution of the original
goal, but if that includes further calls to "shift/1", then it must be called inside a new
"reset", since, unlike in the functional version of |shift|, the captured continuation 
does \emph{not} reestablish the delimited context.

Calls to "reset/3" can be nested.  In this case, a "shift" is handled by the nearest
enclosing "reset", \emph{unless} that "reset" was called with a partially instantiated "Ball" parameter
that does not unify with the parameter to "shift/1". In this case, the "shift" travels outwards
until a "reset" with a unifiable "Ball" parameter is found. This mechanism is intended to allow different
computational effects to be implemented by nesting calls to "reset/3", each matching a different set of
"Ball" terms and each accompanied by a suitable effect handler to deal with the requested effect and then 
resume the computation by calling the continuation.
However, a problem with the current implementation makes it difficult to exploit this behaviour.
Consider the case of two effect handlers "run_inner/1" and "run_outer/1", neither of which do
anything useful, but both correctly invoke their continuations by calling themselves recursively
to reestablish their respective contexts:
\begin{prolog}
  ~run_inner~(G) :- reset(G, inner(X), Cont), run_inner(Cont).
  ~run_outer~(G) :- reset(G, outer(X), Cont), run_outer(Cont).
  ~work~ :- shift(outer(1)), shift(inner(2)).
\end{prolog}
If "work/0" is executed in a nested context by calling "run_outer(run_inner(work))",
% to run "work/0" in a nested context, 
then the "shift(outer(1))"
will pass through the inner reset and be caught by the outer one. However, the captured
continuation contains neither the outer nor the inner prompt. When the continuation is resumed,
the outer prompt is restored by the outer handler, but the inner prompt is still missing, so that
when "shift(inner(2))" is called, there is no matching "reset" to deal with it and an exception will be
raised.

In order to implemented multi-prompt delimited control without using the partially instantiated
"Ball" feature, we will begin with a module "delimcc" that implements nested delimited contexts
correctly on top of the "reset/3" and "shift/1" interface, by exposing an explicit first class prompt
as in \citepos{DyvbigJonesSabry2005} and \citepos{Kiselyov2012} libraries. 
\begin{prolog-framed}[name=delimcc,numbers=left]
  :- module(delimcc, [p_shift/2, p_reset/3, pr_shift/2, pr_reset/3]).

  :- meta_predicate p_reset(+,0,-).
  ~p_reset~(Prompt, Goal, Result) :-
     reset(Goal, Ball, Cont),
     p_cont(Cont, Ball, Prompt, Result).

  ~p_cont~(0, _, _, done) :- !.
  ~p_cont~(Cont, Prompt-Signal, Prompt, susp(Signal, Cont)) :- !.
  ~p_cont~(Cont, Prompt1-Signal1, Prompt, Result) :-
     shift(Prompt1-Signal1),
     p_reset(Prompt, Cont, Result).

  ~p_shift~(Prompt, Signal) :- shift(Prompt-Signal).
\end{prolog-framed}
"Prompt" is a separate argument to both "p_reset/3" and "p_shift/3", and must be a
ground term. The result of the call to "reset/3" on line 5 is dealt with by "p_cont/4": if "Goal" succeeded normally,
then "Result" is set to "done"; if there was a "p_shift", then the resulting
"Ball" is handled by matching the prompt to which it was addressed (line 14) with the prompt associated with
this call to "p_reset/3". If they are equal (line 9), then "Result" is set to "susp(Signal, Cont)",
indicating to the caller of "p_reset/3" that "Goal" was interrupted with the given signal
and capturing the given continuation (which does \emph{not} include a surrounding prompt).
If the prompts are different (line 10), then "shift/1" is called again, rather like rethrowing an exception,
but, crucially, immediately after this call to "shift/1", the continuation captured by the
inner "p_reset/3" is called inside a new instance of the inner prompt. This has the effect that
the continuation captured by the outer prompt contains, at the point of reaching this inner
continuation, a restoration of the inner prompt.

With the aim of drawing a closer parallel between the Prolog and functional implementations of delimited
control, the module also contains "pr_reset/3" and "pr_shift/2", which build on "p_reset/3" and "p_shift/2".
Instead of the "Goal" argument of "p_reset/3", "pr_reset/3" accepts a callable term "Pred" representing
unary predicate. This is called with a single unbound argument, as in "call(Pred, X)", and plays the role of the thunk
|f : unit -> 'a| taken by |push_prompt| in the OCaml library. Instead of the term "Signal" 
taken by "p_shift/2", "pr_shift/2" takes a term "H" representing a binary predicate and is called as
"call(H,K,X)", where "K" represents the continuation as a unary predicate 
and "X" is the unbound variable that will be the final answer returned by "pr_reset/3" in its third argument.
\begin{prolog-framed}[name=delimcc,firstnumber=15]%,numbers=left,title={\emph{delimcc} continued}]
  :- use_module(lambdaki).

  :- meta_predicate pr_reset(+,1,-).
  ~pr_reset~(Prompt, Pred, Result) :-
     p_reset(Prompt, call(Pred, X), Status),
     pr_cont(Status, Prompt, X, Result).

  ~pr_cont~(done, _, X, X).
  ~pr_cont~(susp(H, Cont), Prompt, X, Result) :-
     pr_reset(Prompt, call(H, pr_reset(Prompt, \X^Cont)), Result).

  :- meta_predicate pr_shift(+,2).
  ~pr_shift~(Prompt, H) :- p_shift(Prompt, H).
\end{prolog-framed}
Note that, before being passed to the handler "H", the raw continuation "Cont" is wrapped in its
own delimited context
% , insulating the caller from any computational effects relying on the
% associated "Prompt" that may be used inside it, 
and expressed as a unary predicate by using a lambda abstraction "\X^Cont" (see the supporting
module "lambdaki" in the appendix~\ref{sec:lambdaki}), which turns the 
output variable "X" into a parameter,
and introduces exactly the right copying semantics to allow the continuation to be
called multiple times without the interference that could be caused by the possible
binding of variables inside the original continuation term "Cont". Together these have the
effect of making the continuation look pure from the outside. Note also that the handler
is called inside a delimited context and so may use computational effects too, just as
in the functional version of |shift|.

\section{Memoisation functional style}

\subsection{State handling using delimited control}
\label{sec:ccstate}

Stateful computations are sometimes handled in Prolog by using two extra arguments to pass the state in and out
of all predicates that need to manipulate it. This has the advantage of preserving a  
declarative reading of the program, without resorting to a procedural reading involving side effects, but done 
manually, it can become tedious and
error prone. The \emph{definite clause grammar}, or DCG syntax \cite{PereiraWarren1980}
recognised by most Prologs makes this much easier by hiding the extra arguments---they are inserted and
threaded through all goals automatically when source files containing DCG notation
are read. However, using DCG syntax in this way requires that all the code be lifted into DCG form
even if many parts do not need to manipulate the state. Delimited continuations allow statefulness
to be provided as a computation effect \emph{within} the delimited context, but to appear pure
(like a DCG) from outside the context. \cite{SchrijversDemoenDesouter2013} use state handling
as one of their examples, and we will use a similar approach here, but using the multi-prompt
control predicates introduced in the previous section to allow the safe nesting of state handling
contexts within each other or other effect handlers. The module "ccstate" provides,
within the context of "run_state/3", "app/2" to manipulate the state (using an arbitrary binary predicate
to model a state transition) as a computational effect.
\begin{prolog-framed}[name=ccstate]
  :- module(ccstate, [run_state/4, app/2]).
  :- use_module(library(delimcc)).

  :- meta_predicate app(+,2).
  ~app~(Pr,P)  :- p_shift(Pr,app(P)).

  :- meta_predicate run_state(+,0,?,?).
  ~run_state~(Pr, Goal, S1, S2) :- 
     p_reset(Pr, Goal, Status), 
     cont_state(Status, Pr, S1, S2).

  ~cont_state~(done, _, S, S).
  ~cont_state~(susp(app(P),Cont), Pr, S1, S3) :- 
    call(P, S1, S2), 
    run_state(Pr, Cont, S2, S3).
\end{prolog-framed}
The predicate "run_state/4" reifies this effect
as two extra arguments, that is, it makes stateful effects inside the given goal look like the result
of a pure predicate from the outside, with the last two arguments carrying the initial and final
states.

This interface provides access to a single `blob' of state, but it is quite 
straightforward to build on top of it an effect handler than instead provides an 
unbounded supply of references to mutable cells, which can then be manipulated independently:
\begin{prolog-framed}[name=ccstate]
	:- use_module(library(data/store)).

	:- meta_predicate run_ref(0), ref_app(+,2).
	~run_ref~(Goal) :- store_new(S), run_state(ref, Goal, S, _).

	~ref_new~(X,R)   :- app(ref, store_add(X,R)).
	~ref_app~(R,P)   :- app(ref, store_apply(R,P)).
	~ref_upd~(R,X,Y) :- app(ref, store_upd(R,X,Y)).
\end{prolog-framed}
The library "data/store" is included in the SWI Prolog add-on package "genutils"
and provides a pure, declarative implementation of a reference-value store using 
immutable tree data structures.

\subsection{Memoised nondeterminism using lists}
\label{sec:ccmemo}

The facilities described so far are just enough to implement memoisation as a 
reasonably direct port of the functional, continuation-based approach implemented monadically
in OCaml by \cite{Abdallah2017a}, which was in turn based on \citepos{Johnson1995}
explicit CPS approach. It supports the memoisation of binary predicates (with one input
and one output), which may be recursive or indeed left-recursive. Nondeterminism is
invoked using "choose/2", implemented by the continuation handler "choose/4", and
finally reified as a list of alternative results. (Library "rbutils" is part of the "genutils"
add-on package mentioned above, and provides additional tools for working with the
red-black balanced binary trees implemented in the SWI Prolog built-in library "rbtrees".)
\begin{prolog-framed}[name=ccmemo,numbers=left]
  :- module(ccmemo, [run_memo/2, choose/2, memo/2]).

  :- use_module(library(rbutils)).
  :- use_module(library(delimcc)).
  :- use_module(library(ccstate)).
  :- use_module(lambdaki).

  :- meta_predicate memo(2,-).
  ~memo~(P, ccmemo:mem_call(P,R)) :-
     rb_empty(T),
     ref_new(T,R).

  ~mem_call~(P,R,X,Y) :- pr_shift(memo, h_mem(P,R,X,Y)).
  ~choose~(Xs,X) :- pr_shift(memo, h_choose(Xs,X)).

  :- meta_predicate run_memo(1,-).
  ~run_memo~(P,Result) :- pr_reset(memo, to_list(P), Result).
  ~to_list~(P,[X]) :- call(P,X).

  ~h_choose~(Xs,X,K,Ys) :- foldl(call_append(\X^K),Xs,[],Ys).

  ~h_mem~(P,R,X,Y,K,Ans) :-
     Ky =\Y^K,
     ref_upd(R,Tab,Tab1),
     (  rb_upd(X, entry(Ys,Conts), entry(Ys,[Ky|Conts]), Tab, Tab1)
     -> rb_fold(fst_call_append(Ky),Ys,[],Ans)
     ;  rb_empty(EmptySet),
        rb_insert_new(Tab, X, entry(EmptySet,[]), Tab1),
        call(P,X,YNew),
        ref_app(R, rb_upd(X, entry(Ys,Conts), entry(Ys2,Conts))),
        (  rb_insert_new(Ys,YNew,t,Ys2)
        -> foldl(flip_call_append(YNew), [Ky|Conts], [], Ans)
        ;  Ans = [], Ys2 = Ys
        )
     ).

  ~fst_call_append~(Ky,Y-_,A1,A2) :- call_append(Ky,Y,A1,A2).
  ~flip_call_append~(Y,Ky,A1,A2) :- call_append(Ky,Y,A1,A2).
  ~call_append~(Ky,Y,A1,A2) :- call(Ky,Y,A), append(A1,A,A2).
\end{prolog-framed}
The context for running memoised nondeterministic computations is provided by "run_memo/2", which
installs a prompt named "memo" and calls the supplied predicate "P" using wrapper "to_list/2", which
returns the result of "P" in a (singleton) list. Nondeterminism is handled by "h_choose/4", which applies the
continuation "K" to each item in the supplied list of alternatives "Xs", concatenating the lists of results
produced by each application of the continuation. 

A memoised version of a binary predicate is 
prepared using "memo/2", which creates a new mutable reference containing the initially
empty memo table for that predicate. Calling the memoised version results in a call to "mem_call/4", 
which, invokes the continuation handler "h_mem/6". This works very much like the
\citepos{Abdallah2017a} functional version: if the memoised predicate has already been applied to
the input "X", then there will already be an entry in the memo table "Tab" (line 25), in which case the
newly captured continuation, in the form of a two-argument lambda abstraction "Ky", is added to the 
list of `consumer' continuations associated with "X", and the continuation predicate "Ky" is applied to all
the results produced by the base predicate "P" so far (the list "Ys", line 26), collecting all the 
final results in the list "Ans". If this is the first time the memoised predicate has been applied to 
"X", then a new `producer' is initiated  by adding a new entry to the memo table (line 28), calling the base
predicate "P", and, for each result "YNew", producing an empty answer list if "YNew" is 
already in the results table (line 33) or sending "YNew" to all of the continuations waiting for the
result of applying "P" to "X". The whole of the handler predicate "h_mem/6" is called inside a
"memo" prompt, so that any nondeterminism or memoisation effects triggered inside the call to "P" 
(line 29) result in the following lines of code being executed multiple times and the answers being collected
in the correct way.

As an example of how this memoisation framework can be used, the following code illustrates a left-recursive
predicate "path/2" which implements the transitive closure of "edge/2".
\begin{prolog-framed}[numbers=left]
  :- use_module(ccmemo).

  ~path_memo~(Start, Ends) :-
    memo(path(P), P),
    run_memo(call(P,Start), Ends).

  ~path~(P, N1, N3) :- 
    choose([0,1],U), 
    ( U = 0 -> edge(N1,N3)
    ; U = 1 -> call(P,N1,N2), edge(N2,N3)
    ).

  ~edge~(a,X) :- choose([b,c],X).
  ~edge~(b,d).
  ~edge~(c,d).
  ~edge~(d,X) :- choose([],X).
\end{prolog-framed}
The predicate "path_memo/2" must be called inside a context providing mutable references, \eg, as
"run_ref(path_memo(Start, Ends))".
A few observations on this code are in order. Firstly, "path/3" is written in \emph{open recursive} style;
that is, rather than call itself directly when recursion is required, it calls the first argument "P", which
is assumed to represent the memoised recursive path predicate. The recursion is tied-up without using
an explicit fixed-point operator simply by memoising "path(P)" on line 4 and unifying the result with "P".
The fact that this results in a cyclic term is not a problem. Secondly, all nondeterminism in the
program, both in "edge/2" predicate and "path/3", must be represented using "choose/2",
rather than using Prolog's built-in nondeterminism. This results in a rather non-idiomatic Prolog style, for
example, we cannot simply omit the clause for "edge(d,X)" on line 16 and rely on normal Prolog failure to indicate that there is no edge 
from "d"; we must use "choose([],_)" to express this fact. Thirdly, although not a problem in this example,
the restriction to memoising only binary `input-output' predicates does not fit well with the Prolog style
of using arbitrary arity predicates without restrictions on which arguments may be considered
`inputs' or `outputs'. In short, we have not really implemented \emph{Prolog} style tabling, but rather
transplanted a functional idiom into Prolog. These deficiencies are remedied in the next section.


\section{Idiomatic Prolog tabling}

\subsection{Tabling with non-backtrackable state}
\label{sec:ccnbenv}

The Prolog implementation of delimited continuations interacts in an unproblematic way
with Prolog's nondeterminism and backtracking: any choice points created inside a
"reset/3" are preserved on leaving the delimited context, and subsequent failure will
cause backtracking to a choice point, undoing of variable bindings, and re-execution of 
subsequent goals both inside and outside the delimited context. This means, for example,
the state handling provided by "run_state/4" interacts with nondetermism just as
a DCG or other pure Prolog predicate would, with state transitions being undone on backtracking.

Tabling relies on sharing state \emph{across} alternative branches of computation.
The implementation in the previous section dealt with this by eschewing Prolog nondeterminsm
entirely and using lists to accumlate alternative results.
If we wish to use Prolog's nondeterminism to represent these alternatives, then
the state of the tables must be managed in such a way that changes are not reversed on backtracking.

These two ways of combining of state with nondeterminism (usually referred to as \emph{backtrackable}
and \emph{non-backtrackable} state respectively) can be represented
in a functional settings using \emph{monad transformers} \citep{LiangHudakJones1995}.
Within this framework, the two computational effects can be
layered in either order, with the two resulting monadic types making clear the difference
between them. If |'s| is the type of the state and nondeterminsim is represented as a list,
the type of a monadic computation yielding values of type |'a| is |'s -> ('a * 's) list| 
when layering state on top of nondeterminism, but
|'s -> 'a list * 's| with nondeterminism on top of state. The former corresponds to backatrackable 
state, since there is a state associated with each nondeterministic alternative, while the
latter corresponds to nonbacktrackable state, since there is a single final state resulting from
the traversal process that produced the list of alternatives. The fact that the final state depends
on the traversal process does not compromise the purity of the computation, because the mapping
from initial state to results plus final state is still deterministic and free of side effects.

If we use Prolog's nondeterminism to represent a collection of results, that is, using a predicate
that succeeds once for each result, the
requirements for declarativeness are more stringent: the model theoretic meaning of a predicate is
a \emph{set} of tuples, invariant with respect to the strategy used to find them.
In general, the use of non-backtrackable state means that the sequence of state transitions depends
on the order in which the proof tree of a goal is explored, so it follows that, if a pure logical
reading is to be maintained, the state
should not be exposed in the interface of a predicate that uses it internally.

SWI Prolog provides a number of ways to manage non-backtrackable state, including dynamic predicates
(using "assert/1" and "retract/1"), a `recorded database', and non-backtrackable
global variables (using "nb_setval/2" and "nb_getval/2"). All three of these 
(necessarily) involve a departure from pure Prolog semantics;
however, in the following implementation, the scope of this impurity and the associated
dangers of unprotected global mutable state are strictly limited and
accessed via a carefully controlled computational effect. In addition, the desire to support a more
idiomatic Prolog interface to tabling (see \secrf{arity-and-mode} below) leads to a requirement for mutable cells to be accessed
by caller-specified keys, instead of the allocated references used in the "run_ref/1"
effect handler. Thus, we arrive, using the type declaration scheme
proposed by \cite{SchrijversCostaWielemaker2008}, at the following interface for the module 
"ccnbenv" (non-backtrackable environment):
\begin{prolog}[name=ccnbenv,deletekeywords={ground}]
  :- @pred@ run_nb_env(+pred).
  :- @pred@ nb_app(+key(A), +pred(+A,-A)).
  :- @pred@ nb_app_or_new(+key(A), +pred(+A,-A), +pred(-A)).
  :- @type@ key(A) == ground.
\end{prolog}
The type "key(A)" denotes the type of a key
pointing to a value of type "A", but in practise, any ground term will do.
To minimise the number of underlying calls to "shift/1", values associated with keys are 
created or modified using unary or binary predicates resectively.
The implementation of this module can be found in the appendix~\ref{sec:ccnbenv-imp}.

\subsection{Handling arbitrary predicate arity and mode}
\label{sec:arity-and-mode}

The next requirement for an idiomatic Prolog interface to tabling is the ability to
table predicates of any arity
and with any pattern of argument instantiation (usually referred to as \emph{mode}). This can be done
by maintaining a separate table for each distinct combination of input terms and output
variables encountered in calls to the predicate, that is, treating calls which are
\emph{variants} \citep{SterlingShapiro1994} of each other as forming an equivalence class.
For example, "foo(a,X,Y)" and "foo(a,U,V)" are variants of each other, but "foo(a,X,Y)",
"foo(b,X,Y)" and "foo(a,X,X)" are not. Variant calls will have the same set of solutions and
can share the same table. In the sequel, an equivalence class of calls which are all variants
of each other will be called a `variant class'. The safest way to manipulate variant classess
without resorting to extra-logical operations such as variable equivalence
is to represent them as ground terms, which can be done
using "numbervars/3". This replaces each distinct variable with a term "`&VAR'(N)", where "N"
is an integer. Thus, in the examples above "foo(a,X,Y)" will be represented as "foo(a,`&VAR'(0),`&VAR'(1))",
while "foo(a,X,X)" will be represented as "foo(a,`&VAR'(0),`&VAR'(0))". 

Ground terms representing variant classess can be
used as keys to their associated tables in the non-backtrackable environment effect 
described in \secrf{ccnbenv}. Because the key is derived from the predicate call, there is no need
for an explicit allocation step as there was in the functional version. Note also that the
stratification in table access between the binary predicate at the first level
and the input argument at the second is gone: each variant class combines predicate
and `input' arguments, and is a separate entity at the top level.

\subsection{Using Prolog nondeterminism}

The final requirement is to use Prolog's nondeterminism both at the level of the predicates
being tabled (instead of the awkward to use "choose/2" effect in the functional version)
and to represent nondeterminism outside the tabled environment (instead of reifying nondeterminism
as a list of alternatives). This will have the additional effect that the solutions of tabled
predicates can be explored incrementally, instead of being produced all at once.
In the module "cctable" below, this behaviour is effected in two places. Firstly, if a call is made
that already has a table entry (\ie a consumer call), instead of calling the consumer continuation
for each solution already found and aggregating the final answers, line 30 extracts a solution
from the solution set \emph{nondeterministically}, leaving a choice point, and then calls
the consumer continuation. Any subsequent failure will result in backtracking to this choice
point and application of the continuatuion to the next solution in the set.
Secondly, in "producer/4" (line 37), "call(Generate, Y)" will be nondeterministic, and each time it succeeds,
previously seen solutions can be ignored simply by failing in the attempt to add the value to the 
solution set (lines 39 and 43),
while previously unseen solutions are sent to the registered continuations (including the producer's
continuation) by calling them \emph{disjunctively}, rather than conjunctively. It is significant that
the producer's continution "KP" (line 40) is called \emph{first}: this means that from the outside,
the tabled predicate produces answers lazily, before all solutions have been found.

\begin{prolog-framed}[name=cctable,numbers=left]
  :- module(cctable, [run_tabled/1, cctabled/1]).

  :- use_module(library(delimcc), [p_reset/3, p_shift/2]).
  :- use_module(library(ccnbenv)).
  :- use_module(library(rbutils)).
  :- use_module(lambdaki).

  :- meta_predicate cctabled(0).
  ~cctabled~(Head) :- p_shift(tab, Head).

  :- meta_predicate run_tabled(0).
  ~run_tabled~(Goal) :-
     term_variables(Goal, Ans),
     run_nb_env(run_tab(Goal, Ans)).

  ~head_to_variant_class~(Head, VC) :-
     copy_term_nat(Head, VC),
     numbervars(VC, 0, _).

  ~run_tab~(Goal, Ans) :-
     p_reset(tab, Goal, Status),
     cont_tab(Status, Ans).

  ~cont_tab~(done, _).
  ~cont_tab~(susp(Head, Cont), Ans) :-
     term_variables(Head,Y), 
     K = \Y^Ans^Cont,
     head_to_variant_class(Head, VC),
     nb_app_or_new(VC, consumer(R,K), producer(R)),
     ( R = solns(Solns) -> rb_gen(Y, _, Solns), run_tab(Cont, Ans)
     ; R = producer     -> run_tab(producer(VC, \Y^Head, K, Ans), Ans)
     ).

  ~consumer~(solns(Solns), K, tab(Solns,Ks), tab(Solns,[K|Ks])).
  ~producer~(producer, tab(Solns,[])) :- rb_empty(Solns).

  ~producer~(VC, Generate, KP, Ans) :-
     call(Generate, Y),
     nb_app(VC, new_soln(Y,Ks)),
     member(K,[KP|Ks]), 
     call(K,Y,Ans).

  ~new_soln~(Y, Ks, tab(Ys1,Ks), tab(Ys2,Ks)) :- rb_add(Y,t,Ys1,Ys2). 
\end{prolog-framed}

\subsection{Program transformation}
While the module "cctable" can be used as-is, by calling tabled goals using the
meta-predicate "cctabled/1", the usual approach to tabling in Prolog is to support a
declaration that a certain predicate should be tabled, such that it can then be
called without any further decoration. This can be achieved using a very shallow
program transformation, similar to that described by \cite{DesouterVan-DoorenSchrijvers2015}.
The implementation is given in the appendix, but result is that the example given 
in \secrf{ccmemo} can be written (now using DCG notation for "path/2") as:
\begin{prolog-framed}
  :- use_module(cctable).
  :- use_module(ccmacros).

  ~path_memo~(Start, End) :- run_tab(path(Start,End)).

  :- table path/2.
  ~path~ --> edge; path, edge.

  ~edge~(a,b).  ~edge~(a,c).  ~edge~(b,d).  ~edge~(c,d).
\end{prolog-framed}
The "path/2" predicate is transformed via macro expansion on loading to
\begin{prolog}
  ~path~(N1, N2)     :- cctabled(`path#'(N1, N2)).
  `~path#~'(N1, N3) :- edge(N1, N3); path(N1, N2), edge(N2, N3).
\end{prolog}
As well as the DCG translation, the original predicate is renamed by
adding "`#'" to the name, while "path/2" is redirected to a tabled
call of the renamed predicate.



\section{Related work}
The implementation presented in this report was largely derived from the OCaml
version reported by \cite{Abdallah2017a}, but it shares many similarities with
the tabling library of \cite{DesouterVan-DoorenSchrijvers2015}. For example,
the use of "numbervars/3" to represent variant classes as ground terms.

Trie vs balanced binary tree for variant classes and answer sets.

Use of mutable data structures means that tabling algorithm is imperative.
[Use of "nb_linkval"?] Much less term copying.

In addition the
predicate renaming methods using program transformation module "ccmacros" 
(listed in the appendix~\ref{sec:ccmacros}) was derived from the version of Desouter et al.'s
library that is currently included in SWI Prolog.

\section{Conclusions}

\Burns \quad Mmm, excellent.

\appendix
\section{Supporting code}

Modules "lambdaki", "ccstate", "ccnbenv" and "delimcc" can be found in the SWI Prolog
add-on package "genutils", which can be installed in SWI Prolog with the command
"pack_install(genutils)". The rest of the code presented in this report can be
found at \url{https://github.com/samer--/cctable}.

\subsection{Lambda abstractions}
\label{sec:lambdaki}

This module is a minimal implementation of lambda terms, which are callable terms representing
predicates taking one or more arguments, which can be useful for high-order programming and
reducing the need to define trivial auxillary predicates. It is a simplified version of 
\citepos{Neumerkel2009} "lambda" library,
supporting only unary and binary application with no free variables.

\begin{prolog-framed}[name=lambdaki]
  :- module(lambdaki, [ (\)/2, (\)/3, (^)/3, (^)/4 ]).

  :- meta_predicate \(1,?), \(2,?,?).
  :- meta_predicate ^(?,0,?), ^(?,1,?,?).

  ~\~(M:Hats, A1)     :- copy_term(Hats, Copy), call(M:Copy, A1).
  ~\~(M:Hats, A1, A2) :- copy_term(Hats, Copy), call(M:Copy, A1, A2).

  ~^~(A1, P, A1)     :- call(P).
  ~^~(A1, P, A1, A2) :- call(P, A2).
\end{prolog-framed}

\subsection{Non-backtrackable mutable environment}
\label{sec:ccnbenv-imp}

This module, "ccnbenv", provides an environment containing non-backtrackable mutable
cells accessible via caller-determined keys, as discussed in \secrf{ccnbenv}.
\begin{prolog-framed}[name=ccnbenv]
  :- module(ccnbenv, [ run_nb_env/1, nb_app/2, nb_app_or_new/3 ]).

  :- use_module(library(delimcc)).
  :- use_module(library(rbutils)).

  :- meta_predicate run_nb_env(0).
  ~run_nb_env~(Goal) :- 
     gensym(nbenv_keys,R0), rb_empty(Empty),
     setup_call_cleanup(nb_setval(R0,Empty), run(Goal,R0), cleanup(R0)).

  ~cleanup~(R0) :-
     nb_getval(R0, KeyMap),
     rb_map(KeyMap, nb_delete),
     nb_delete(R0).

  ~run~(Goal,R0) :- p_reset(nbenv,Goal,Status), cont(Status,R0).
  ~cont~(done, _).
  ~cont~(susp(P,Cont),R0) :- 
    nb_getval(R0,M), call(P,R0,M), run(Cont,R0).

  ~app~(K,P,_,M) :- 
     rb_lookup(K,R,M),
     nb_getval(R,X), call(P,X,Y), nb_setval(R,Y).

  ~app_or_new~(K,P,New,R0,M1) :- 
     rb_upd_or_ins(K,Act,M1,M2),
     ( Act =update(R,R) -> nb_getval(R,X), call(P,X,Y), nb_setval(R,Y)
     ; Act =insert(R)    -> gensym(nbenv,R), call(New,X),
                            nb_setval(R0,M2), nb_setval(R,X)
     ).

  :- meta_predicate nb_app(+,2), nb_app_or_new(+,2,1).
  ~nb_app~(K,P) :- p_shift(nbenv, app(K,P)).
  ~nb_app_or_new~(K,P,Q) :- p_shift(nbenv, app_or_new(K,P,Q)).
\end{prolog-framed}

\subsection{Shallow program transformation}
\label{sec:ccmacros}

The module "ccmaros" implements a shallow program transformation to support
tabling. Predicates decalared `tabled' are renamed (using the special
SWI Prolog hook "prolog:rename_predicate/2" to appendng
a "`#'" to their given name) and the original predicate name defined
as a metacall of the renamed predicate via cctable/1, which is 
assumed to be available in the module where the tabled precicate
is defined. 

\begin{prolog-framed}[name=ccnbenv,label=lst:ccnbenv]
  :- module(ccmacros, [op(1150, fx, table)]).
  :- op(1150, fx, table).

  ~system:term_expansion~((:- table(Specs)), Clauses) :- 
     foldl_clist(expand_cctab, Specs, Clauses, []).

  ~foldl_clist~(P,(A,B)) --> !, call(P,A), foldl_clist(P,B).
  ~foldl_clist~(P,A)     --> call(P,A).

  ~prolog:rename_predicate~(M:Head, M:Worker) :-
     `&flushed_predicate'(M:`&cctabled'(_)),
     call(M:`&cctabled'(Head)), !,
     head_worker(Head, Worker).

  ~expand_cctab~(Name//Arity) --> !, 
     {A2 is Arity+2}, 
     expand_cctab(Name/A2).

  ~expand_cctab~(Name/Arity) --> 
     { functor(Head, Name, Arity), head_worker(Head, Worker)},
     [ (:- discontiguous(`&cctabled'/1))
     , `&cctabled'(Head)
     , (Head :- cctabled(Worker))
     ]. 

  ~head_worker~(Head, Worker) :-
    Head   =.. [H|As], atom_concat(H, `#', W),
    Worker =.. [W|As].
\end{prolog-framed}

% vim: ts=2 sw=2 expandtab
