
\section{Introduction and background}
\seclab{intro}

Tabling, or memoisation \citep{Michie1968} is a well known technique for speeding up computations
by saving and reusing the results of earlier subcomputations instead of repeating
them. In other contexts, this strategy is called `dynamic programming', and, when
used effectively, can reduce algorithms with exponential time complexity to polynomial
or linear complexity. 

In the field of logic programming, memoisation is referred to as \emph{tabling},
and usually includes the ability to handle recursive, non-deterministic predicates, including
so-called \emph{left-recursive} predicates that would otherwise result in non-termination using 
depth-first search strategies
such as SLD resolution, as provided, for example, in Prolog. Alternative strategies
such as OLDT resolution \citep{TamakiSato1986} and SLG resolution \citep{ChenWarren1993} have
been available for some time in Prologs such as XSB and YAP, but it was recognised
well before that the forms of deduction that these methods embody are closely related to
the efficient parsing algorithm invented by \cite{Earley1970}, the generalisation of which
was dubbed `Earley deduction' \citep{Warren1975,PereiraWarren1983,Porter1986}.

In the functional programming community, the problem of efficient parsing has been
addressed using memoising parser combinators \citep{Norvig1991,Leermakers1993}.
\cite{Abdallah2017a} gives an overview of this approach and focusses on the method of
\cite{Johnson1995}, which is particularly
interesting in that it handles left-recursive grammars using essentially the same 
mechanism as Earley's algorithm and, by extension, the OLDT and SLG resolution methods
used in tabled Prologs. Those methods rely on the \emph{suspension} of chains of deduction,
which can then be resumed under different conditions. Johnson's method (implemented in the
functional programming language Scheme) uses continuation
passing style \citep{SussmanSteele1975} to achieve the same effect, allowing threads of
computation to be suspended and resumed multiple times. Indeed, transformation of a program
into continuation passing style, or the use of continuation capturing control operators
such as |call-with-current-continuation| in Scheme, is a very powerful approach
to implementing many computational effects within a declarative language \cite{Filinski1999}.

Continuation passing style has been investigated as a basis for implementing Prolog itself
\citep{TarauDahl1994,Lindgren1994,Neumerkel1995} and for providing useful computational effects
from within in Prolog \citep{TrauDahl1994a,TarauDahl1998}. 
[Tabling with continuations: \cite{De-GuzmanCarroHermenegildo2008,GuzmanCarroHermenegildo2008}
What about Ramesh and Chen (1994,1997)?]
Recently, continuation capturing control operators have been implemented in hProlog and
SWI Prolog \citep{SchrijversDemoenDesouter2013}, and subsequently used to implement
tabling completely in Prolog, without any further low level support 
\cite{DesouterVan-DoorenSchrijvers2015}. This report describes a similar approach, first
translating \citepos{Johnson1995} functional memoisation into pure, declarative Prolog,
and then making minimal changes to implement tabling as it is more usually seen in Prolog,
while retaining most of the declarativeness of the functional version. [Contribution? Differences from
previous methods?]

The system presented here was developed using SWI Prolog \citep{WielemakerSchrijversTriska2012},
which includes an implementation of delimited continuations
derived from \citepos{SchrijversDemoenDesouter2013} original implementation for hProlog.
We assume some familiarity with Prolog in general. In the program listings that follow, the code
has been rendered using typographic features not available in the real source; in particular
\verb|:-| is rendered as ":-", \verb|->| as "->", \verb|-->| as "-->", and variables with numeric suffixes
are rendered with subscripts. In addition, Prolog lambda expressions \citep{Neumerkel2009} are typeset, for example,
as "\X^Y^Goal", but coded as \verb|\X^Y^Goal|.

\section{Multi-prompt delimited control in Prolog}

Continuation passing style and continuation-based control operators have been well studied in the
context of lambda calculus and functional programming \citep{SussmanSteele1975}.
The idea of delimited continuations was arrived at independently by \cite{Felleisen1988} and
\cite{DanvyFilinski1990}. Multiple, first class, independently addressible prompts were introduced
by \cite{DyvbigJonesSabry2005} in their monadic Haskell implementation, which was recast
as an OCaml library to be used in `direct style' (i.e. using neither monadic nor explicit continuation 
passing styles) by \cite{Kiselyov2012}. The basic operation of multi-prompt delimited
control can be described in terms of the |new_prompt|, |push_prompt| and |shift| operators provided by
this library, which have the following OCaml types (in which Greek letters denote type variables):
\begin{ocamlet}
	new_prompt	: unit -> 'a prompt
	push_prompt	: 'a prompt -> (unit -> 'a) -> 'a
	shift        : 'a prompt -> (('b -> 'a) -> 'a) -> 'b
\end{ocamlet}
Given a prompt |p| with answer type |'a|, created using |new_prompt|, a thunk |f : unit -> 'a| is evaluated
in a context delimited by the prompt |p| by calling |push_prompt p f|, which plays the role of |reset| in 
\citepos{DanvyFilinski1990} framework.
Calls to |push_prompt|, using the same or differing prompts, can be nested arbitrarily.
If, inside |f|, there is a call to |shift p h|, the
continuation out to the nearest instance of |push_prompt p| is captured as a function |k : 'b -> 'a|, and passed to the handler
|h|, whose return value is then returned from the enclosing |push_prompt|. The captured continuation includes an implict
enclosing |push_prompt p|, which hides any further calls to |shift p| it may contain, and means that, from the outside,
it looks like a pure function, which can be called zero, once, or many times. During a call to the handler |h|,
the original outer prompt stays in place, so that any calls to |shift p| made by the handler do not
escape the original delimited context. Other frameworks provide a different set of control operators, but
they are all closely related and expressible in terms of each other \citep{Shan2004}.

\citepos{SchrijversDemoenDesouter2013} implementation of delimited continuations for Prolog provides two
primitives, "reset/3" and "shift/1". If a Prolog goal is called as "reset(Goal, Ball, Cont)", with both
"Ball" and "Cont" unbound, then "Goal" is executed inside a delimited context. If it completes
successfully, then "Cont" is unified with "0".  If "shift/1" is called inside "Goal", then "Cont" is bound
to a callable representation of the continuation from that point out to the enclosing "reset", "Ball"
is bound to the argument of "shift/1", and control is passed to the code following the "reset".
The continuation "Cont" can be called subsequently, resuming the interrupted execution of the original
goal, but if that includes further calls to "shift/1", then it must be called inside a new
"reset", since, unlike in the functional version of |shift|, the captured continuation 
does \emph{not} reestablish the delimited context.

Calls to "reset/3" can be nested.  In this case, a "shift" is handled by the nearest
enclosing "reset", \emph{unless} that "reset" was called with a partially instantiated "Ball" parameter
that does not unify with the parameter to "shift/1". In this case, the "shift" travels outwards
until a "reset" with a unifiable "Ball" parameter is found. This mechanism is intended to allow different
computational effects to be implemented by nesting calls to "reset/3", each matching a different set of
"Ball" terms and each accompanied by a suitable effect handler to deal with the requested effect and then 
resume the computation by calling the continuation.\footnote{Note that this feature only works correctly
in SWI Prolog beginning with version 7.5.12.}

% In order to support the rest of the code presented here,
We will begin with a module "delimcc" that provides an alternative interface to delimited control that
uses a well typed result term instead of the `defaulty' and ill-typed "Cont" produced by "reset/3",
and also avoids the non-logical behaviour with partially instantiated "Ball" terms by taking instead
an explicit first class prompt
as in \citepos{DyvbigJonesSabry2005} and \citepos{Kiselyov2012} libraries. 
\begin{prolog-framed}[name=delimcc]
  :- module(delimcc, [p_shift/2, p_reset/3, pr_shift/2, pr_reset/3]).

  :- meta_predicate p_reset(+,0,-).
  ~p_reset~(Prompt, Goal, Result) :-
    reset(Goal, Prompt-Signal, Cont),
    (Cont==0 -> Result = done; Result = susp(Signal, Cont)).

  ~p_shift~(Prompt, Signal) :- shift(Prompt-Signal).
\end{prolog-framed}
"Prompt" is a separate argument to both "p_reset/3" and "p_shift/3", and must be a
ground term. The result of the call to "p_reset/3" is either "done" to indicate no continuation
was captured, or "susp(Signal,Cont)" to indicate that "Signal" was sent to this prompt and
the captured continuation is "Cont".

With the aim of drawing a closer parallel between the Prolog and functional implementations of delimited
control, the module also contains "pr_reset/3" and "pr_shift/2", which build on "p_reset/3" and "p_shift/2".
Instead of the "Goal" argument of "p_reset/3", "pr_reset/3" accepts a callable term "Pred" representing a
unary predicate. This is called with a single unbound argument, as in "call(Pred, X)", and plays the role of the thunk
|f : unit -> 'a| taken by |push_prompt| in the OCaml library. Instead of the term "Signal" 
taken by "p_shift/2", "pr_shift/2" takes a term "H" representing a binary predicate and is called as
"call(H,K,X)", where "K" represents the continuation as a unary predicate 
and "X" is the unbound variable that will be the final answer returned by "pr_reset/3" in its third argument.
\begin{prolog-framed}[name=delimcc,firstnumber=15]%,numbers=left,title={\emph{delimcc} continued}]
  :- use_module(lambdaki).

  :- meta_predicate pr_reset(+,1,-).
  ~pr_reset~(Prompt, Pred, Result) :-
     p_reset(Prompt, call(Pred, X), Status),
     pr_cont(Status, Prompt, X, Result).

  ~pr_cont~(done, _, X, X).
  ~pr_cont~(susp(H, Cont), Prompt, X, Result) :-
     pr_reset(Prompt, call(H, pr_reset(Prompt, \X^Cont)), Result).

  :- meta_predicate pr_shift(+,2).
  ~pr_shift~(Prompt, H) :- p_shift(Prompt, H).
\end{prolog-framed}
Note that, before being passed to the handler "H", the raw continuation "Cont" is wrapped in its
own delimited context
% , insulating the caller from any computational effects relying on the
% associated "Prompt" that may be used inside it, 
and expressed as a unary predicate by using a lambda abstraction "\X^Cont" (see the supporting
module "lambdaki" in the appendix~\ref{sec:lambdaki}), which turns the 
output variable "X" into a parameter,
and introduces exactly the right copying semantics to allow the continuation to be
called multiple times without the interference that could be caused by the possible
binding of variables inside the original continuation term "Cont". Together these have the
effect of making the continuation look pure from the outside. Note also that the handler
is called inside a delimited context and so may use computational effects too, just as
in the functional version of |shift|.

\section{Memoisation functional style}

\subsection{State handling using delimited control}
\label{sec:ccstate}

Stateful computations are sometimes handled in Prolog by using two extra arguments to pass the state in and out
of all predicates that need to manipulate it. This has the advantage of preserving a  
declarative reading of the program, without resorting to a procedural reading involving side effects, but done 
manually, it can become tedious and
error prone. The \emph{definite clause grammar}, or DCG syntax \cite{PereiraWarren1980}
recognised by most Prologs makes this much easier by hiding the extra arguments---they are inserted and
threaded through all goals automatically when source files containing DCG notation
are read. However, using DCG syntax in this way requires that all the code be lifted into DCG form
even if many parts do not need to manipulate the state. Delimited continuations allow statefulness
to be provided as a computation effect \emph{within} the delimited context, but to appear pure
(like a DCG) from outside the context. \cite{SchrijversDemoenDesouter2013} use state handling
as one of their examples, and we will use a similar approach here, but using the multi-prompt
control predicates introduced in the previous section to allow the safe nesting of state handling
contexts within each other or other effect handlers. The module "ccstate" provides,
within the context of "run_state/3", "app/2" to manipulate the state (using an arbitrary binary predicate
to model a state transition) as a computational effect.
\begin{prolog-framed}[name=ccstate]
  :- module(ccstate, [run_state/4, app/2]).
  :- use_module(library(delimcc)).

  :- meta_predicate app(+,2).
  ~app~(Pr,P)  :- p_shift(Pr,app(P)).

  :- meta_predicate run_state(+,0,?,?).
  ~run_state~(Pr, Goal, S1, S2) :- 
     p_reset(Pr, Goal, Status), 
     cont_state(Status, Pr, S1, S2).

  ~cont_state~(done, _, S, S).
  ~cont_state~(susp(app(P),Cont), Pr, S1, S3) :- 
    call(P, S1, S2), 
    run_state(Pr, Cont, S2, S3).
\end{prolog-framed}
The predicate "run_state/4" reifies this effect
as two extra arguments, that is, it makes stateful effects inside the given goal look like the result
of a pure predicate from the outside, with the last two arguments carrying the initial and final
states.

This interface provides access to a single `blob' of state, but it is quite 
straightforward to build on top of it an effect handler than instead provides an 
unbounded supply of references to mutable cells, which can then be manipulated independently:
\begin{prolog-framed}[name=ccstate]
  :- use_module(library(data/store)).

  :- meta_predicate run_ref(0), ref_app(+,2).
  ~run_ref~(Goal) :- store_new(S), run_state(ref, Goal, S, _).

  ~ref_new~(X,R)   :- app(ref, store_add(X,R)).
  ~ref_app~(R,P)   :- app(ref, store_apply(R,P)).
  ~ref_upd~(R,X,Y) :- app(ref, store_upd(R,X,Y)).
\end{prolog-framed}
The library "data/store" is included in the SWI Prolog add-on package "genutils"
and provides a pure, declarative implementation of a reference-value store using 
immutable tree data structures.

\subsection{Memoised nondeterminism using lists}
\label{sec:ccmemo}

The facilities described so far are just enough to implement memoisation as a 
reasonably direct port of the functional, continuation-based approach implemented monadically
in OCaml by \cite{Abdallah2017a}, which was in turn based on \citepos{Johnson1995}
explicit CPS approach. It supports the memoisation of binary predicates (with one input
and one output), which may be recursive or indeed left-recursive. Nondeterminism is
invoked using "choose/2", implemented by the continuation handler "choose/4", and
finally reified as a list of alternative results. (Library "rbutils" is part of the "genutils"
add-on package mentioned above, and provides additional tools for working with the
red-black balanced binary trees implemented in the SWI Prolog built-in library "rbtrees".)
\begin{prolog-framed}[name=ccmemo,numbers=left]
  :- module(ccmemo, [run_memo/2, choose/2, memo/2]).

  :- use_module(library(rbutils)).
  :- use_module(library(delimcc)).
  :- use_module(library(ccstate)).
  :- use_module(lambdaki).

  :- meta_predicate memo(2,-).
  ~memo~(P, ccmemo:mem_call(P,R)) :-
     rb_empty(T),
     ref_new(T,R).

  ~mem_call~(P,R,X,Y) :- pr_shift(memo, h_mem(P,R,X,Y)).
  ~choose~(Xs,X) :- pr_shift(memo, h_choose(Xs,X)).

  :- meta_predicate run_memo(1,-).
  ~run_memo~(P,Result) :- pr_reset(memo, to_list(P), Result).
  ~to_list~(P,[X]) :- call(P,X).

  ~h_choose~(Xs,X,K,Ys) :- foldl(call_append(\X^K),Xs,[],Ys).

  ~h_mem~(P,R,X,Y,K,Ans) :-
     Ky =\Y^K,
     ref_upd(R, Tab, Tab1),
     (  rb_upd(X, entry(Ys,Conts), entry(Ys,[Ky|Conts]), Tab, Tab1)
     -> rb_fold(fst_call_append(Ky), Ys, [], Ans)
     ;  rb_empty(EmptySet),
        rb_add(X, entry(EmptySet,[]), Tab, Tab1),
        call(P,X,YNew),
        ref_app(R, rb_upd(X, entry(Ys,Conts), entry(Ys2,Conts))),
        (  rb_add(YNew, t, YS, Ys2)
        -> foldl(flip_call_append(YNew), [Ky|Conts], [], Ans)
        ;  Ans = [], Ys2 = Ys
        )
     ).

  ~fst_call_append~(Ky,Y-_,A1,A2) :- call_append(Ky,Y,A1,A2).
  ~flip_call_append~(Y,Ky,A1,A2) :- call_append(Ky,Y,A1,A2).
  ~call_append~(Ky,Y,A1,A2) :- call(Ky,Y,A), append(A1,A,A2).
\end{prolog-framed}
The context for running memoised nondeterministic computations is provided by "run_memo/2", which
installs a prompt named "memo" and calls the supplied predicate "P" using wrapper "to_list/2", which
returns the result of "P" in a (singleton) list. Nondeterminism is handled by "h_choose/4", which applies the
continuation "K" to each item in the supplied list of alternatives "Xs", concatenating the lists of results
produced by each application of the continuation. 

A memoised version of a binary predicate is 
prepared using "memo/2", which creates a new mutable reference containing the initially
empty memo table for that predicate. Calling the memoised version results in a call to "mem_call/4", 
which, invokes the continuation handler "h_mem/6". This works very much like the
\citepos{Abdallah2017a} functional version: if the memoised predicate has already been applied to
the input "X", then there will already be an entry in the memo table "Tab" (line 25), in which case the
newly captured continuation, in the form of a two-argument lambda abstraction "Ky", is added to the 
list of `consumer' continuations associated with "X", and the continuation predicate "Ky" is applied to all
the results produced by the base predicate "P" so far (the list "Ys", line 26), collecting all the 
final results in the list "Ans". If this is the first time the memoised predicate has been applied to 
"X", then a new `producer' is initiated  by adding a new entry to the memo table (line 28), calling the base
predicate "P", and, for each result "YNew", producing an empty answer list if "YNew" is 
already in the results table (line 33) or sending "YNew" to all of the continuations waiting for the
result of applying "P" to "X". The whole of the handler predicate "h_mem/6" is called inside a
"memo" prompt, so that any nondeterminism or memoisation effects triggered inside the call to "P" 
(line 29) result in the following lines of code being executed multiple times and the answers being collected
in the correct way.

As an example of how this memoisation framework can be used, the following code illustrates a left-recursive
predicate "path/2" which implements the transitive closure of "edge/2".
\begin{prolog-framed}[numbers=left]
  :- use_module(ccmemo).

  ~path_memo~(Start, Ends) :-
    memo(path(P), P),
    run_memo(call(P,Start), Ends).

  ~path~(P, N1, N3) :- 
    choose([0,1],U), 
    ( U = 0 -> edge(N1,N3)
    ; U = 1 -> call(P,N1,N2), edge(N2,N3)
    ).

  ~edge~(a,X) :- choose([b,c],X).
  ~edge~(b,d).
  ~edge~(c,d).
  ~edge~(d,X) :- choose([],X).
\end{prolog-framed}
The predicate "path_memo/2" must be called inside a context providing mutable references, \eg, as
"run_ref(path_memo(Start, Ends))".
A few observations on this code are in order. Firstly, "path/3" is written in \emph{open recursive} style;
that is, rather than call itself directly when recursion is required, it calls the first argument "P", which
is assumed to represent the memoised recursive path predicate. The recursion is tied-up without using
an explicit fixed-point operator simply by memoising "path(P)" on line 4 and unifying the result with "P".
The fact that this results in a cyclic term is not a problem. Secondly, all nondeterminism in the
program, both in "edge/2" predicate and "path/3", must be represented using "choose/2",
rather than using Prolog's built-in nondeterminism. This results in a rather non-idiomatic Prolog style, for
example, we cannot simply omit the clause for "edge(d,X)" on line 16 and rely on normal Prolog failure to indicate that there is no edge 
from "d"; we must use "choose([],_)" to express this fact. Thirdly, although not a problem in this example,
the restriction to memoising only binary `input-output' predicates does not fit well with the Prolog style
of using arbitrary arity predicates without restrictions on which arguments may be considered
`inputs' or `outputs'. In short, we have not really implemented \emph{Prolog} style tabling, but rather
transplanted a functional idiom into Prolog. These deficiencies are remedied in the next section.


\section{Idiomatic Prolog tabling}
\label{sec:idiomatic}

\subsection{Tabling with non-backtrackable state}
\label{sec:ccnbstate}

The Prolog implementation of delimited continuations interacts in an unproblematic way
with Prolog's nondeterminism and backtracking: any choice points created inside a
"reset/3" are preserved on leaving the delimited context, and subsequent failure will
cause backtracking to a choice point, undoing of variable bindings, and re-execution of 
subsequent goals both inside and outside the delimited context. This means, for example,
the state handling provided by "run_state/4" interacts with nondetermism just as
a DCG or other pure Prolog predicate would, with state transitions being undone on backtracking.

Tabling relies on sharing state \emph{across} alternative branches of computation.
The implementation in the previous section dealt with this by eschewing Prolog nondeterminsm
entirely and using lists to accumlate alternative results.
If we wish to use Prolog's nondeterminism to represent these alternatives, then
the state of the tables must be managed in such a way that changes are not reversed on backtracking.

These two ways of combining of state with nondeterminism (usually referred to as \emph{backtrackable}
and \emph{non-backtrackable} state respectively) can be represented
in a functional settings using \emph{monad transformers} \citep{LiangHudakJones1995}.
Within this framework, the two computational effects can be
layered in either order, with the two resulting monadic types making clear the difference
between them. If |'s| is the type of the state and nondeterminsim is represented as a list,
the type of a monadic computation yielding values of type |'a| is |'s -> ('a * 's) list| 
when layering state on top of nondeterminism, but
|'s -> 'a list * 's| with nondeterminism on top of state. The former corresponds to backatrackable 
state, since there is a state associated with each nondeterministic alternative, while the
latter corresponds to nonbacktrackable state, since there is a single final state resulting from
the traversal process that produced the list of alternatives. The fact that the final state depends
on the traversal process does not compromise the purity of the computation, because the mapping
from initial state to results plus final state is still deterministic and free of side effects.

If we use Prolog's nondeterminism to represent a collection of results, that is, using a predicate
that succeeds once for each result, the
requirements for declarativeness are more stringent: the model theoretic meaning of a predicate is
a \emph{set} of tuples, invariant with respect to the strategy used to find them.
In general, the use of non-backtrackable state means that the sequence of state transitions depends
on the order in which the proof tree of a goal is explored, so it follows that, if a pure logical
reading is to be maintained, the state
should not be exposed in the interface of a predicate that uses it internally.

SWI Prolog provides a number of ways to manage non-backtrackable state, including dynamic predicates
(using "assert/1" and "retract/1"), a `recorded database', and non-backtrackable
global variables (using "nb_setval/2" and "nb_getval/2"). All three of these 
(necessarily) involve a departure from pure Prolog semantics.
Using "run_nb_state/4" (implementation given in appendix~\ref{app:ccnbstate}), the scope of this 
impurity and the associated dangers of unprotected global mutable state are strictly limited to 
the introduction of one mutable cell accessed via a carefully controlled computational effect,
 with essentially the same interface as the backtrackable state effect provided by "run_state/4" in module
"ccstate" (\secrf{ccstate}). 

\subsection{Handling arbitrary predicate arity and mode}
\label{sec:arity-and-mode}

The next requirement for an idiomatic Prolog interface to tabling is the ability to
table predicates of any arity
and with any pattern of argument instantiation (usually referred to as \emph{mode}). This can be done
by maintaining a separate table for each distinct combination of input terms and output
variables encountered in calls to the predicate, that is, treating calls which are
\emph{variants} \citep{SterlingShapiro1994} of each other as forming an equivalence class.
For example, "foo(a,X,Y)" and "foo(a,U,V)" are variants of each other, but "foo(a,X,Y)",
"foo(b,X,Y)" and "foo(a,X,X)" are not. Variant calls will have the same set of solutions and
can share the same table. In the sequel, an equivalence class of calls which are all variants
of each other will be called a `variant class'.\footnote{It should be noted that manipulating terms on
the basis of what variables they contain involves stepping up out of the pure, declarative
fragment of Prolog in to pure Prolog's \emph{metalanguage}. The fact that Prolog serves as
its own metalanguage means that this distinction is easily overlooked.} The safest way to manipulate 
variant classess without resorting to xtra-logical operations such as variable equivalence
is to represent them as ground terms as soon as possible, which can be done
using "numbervars/3". This replaces each distinct variable with a term "`&VAR'(N)", where "N"
is an integer. Thus, in the examples above "foo(a,X,Y)" will be represented as "foo(a,`&VAR'(0),`&VAR'(1))",
while "foo(a,X,X)" will be represented as "foo(a,`&VAR'(0),`&VAR'(0))". 

Ground terms representing variant classes can be
used as keys to their associated tables in an associative map which is in turn stored in
the non-backtrackable mutable cell provided "run_nb_state/4", described in \secrf{ccnbstate}.
Because the key is derived from the predicate call, there is no need
for an explicit allocation step as there was in the functional version. Note also that the
stratification in table access between the binary predicate at the first level
and the input argument at the second is gone: each variant class combines predicate
and `input' arguments, and is a separate entity at the top level.

The `output' from calling a tabled predicate with a particular variant class consists of
the bindings of the variables in the variant class, which may be distributed in any
way across the parameters of the predicate, including possible partial instantiations
of arguments. These variables can be extracted using the standard Prolog extra-logical
operation "term_variables/2". Each solution of a tabled variant class can then be represented
as a list of the resulting values of these variables.

\subsection{Using Prolog nondeterminism}

The final requirement is to use Prolog's nondeterminism both at the level of the predicates
being tabled (instead of the awkward to use "choose/2" effect in the functional version)
and to represent nondeterminism outside the tabled environment (instead of reifying nondeterminism
as a list of alternatives). This will have the additional effect that the solutions of tabled
predicates can be explored incrementally, instead of being produced all at once.
In the module "cctable" below, this behaviour is effected in two places. Firstly, if a call is made
that already has a table entry (\ie a consumer call), instead of calling the consumer continuation
for each solution already found and aggregating the final answers, line 27 extracts a solution
from the solution set \emph{nondeterministically}, leaving a choice point, and then calls
the consumer continuation. Any subsequent failure will result in backtracking to this choice
point and application of the continuatuion to the next solution in the set.
Secondly, in "producer/4" (line 37), "call(Generate, Y)" will be nondeterministic, and each time it succeeds,
previously seen solutions can be ignored simply by failing in the attempt to add the value to the 
solution set (line 44),
while previously unseen solutions are sent to the registered continuations (including the producer's
continuation) by calling them \emph{disjunctively}, rather than conjunctively (line 40). It is significant that
the producer's continution "KP" is called \emph{first}: this means that from the outside,
the tabled predicate produces answers lazily, before all solutions have been found.

\begin{prolog-framed}[name=cctable,numbers=left]
  :- module(cctable, [run_tabled/1, cctabled/1]).

  :- use_module(library(delimcc), [p_reset/3, p_shift/2]).
  :- use_module(library(ccnbstate), [run_nb_state/4, app/4]).
  :- use_module(library(rbutils)).
  :- use_module(lambdaki).

  :- meta_predicate cctabled(0).
  ~cctabled~(Work) :- p_shift(tab, Work).

  :- meta_predicate run_tabled(0).
  ~run_tabled~(Goal) :-
     term_variables(Goal, Ans), 
     rb_empty(Empty),
     run_nb_state(state, run_tab(Goal, Ans), Empty, _).

  ~run_tab~(Goal, Ans) :-
     p_reset(tab, Goal, Status),
     cont_tab(Status, Ans).

  ~cont_tab~(done, _).
  ~cont_tab~(susp(Work, Cont), Ans) :-
     term_variables(Work,Y), 
     K = \Y^Ans^Cont,
     numbervars_copy(Work, VC),
     app(state, new_cont(VC, K, A)),
     (  A = solns(Ys) -> rb_in(Y, _, Ys), run_tab(Cont, Ans)
     ;  A = producer -> run_tab(producer(VC, \Y^Work, K, Ans), Ans)
     ).

  ~new_cont~(VC, K, solns(Ys), S1, S2) :- 
     rb_upd(VC, tab(Ys,Ks), tab(Ys,[K|Ks]), S1, S2).
  ~new_cont~(VC, K, producer, S1, S2) :-
     rb_empty(Ys), 
     rb_add(VC, tab(Ys,[K]), S1, S2).

  ~producer~(VC, Generate, KP, Ans) :-
     call(Generate, Y),
     app(state, new_soln(VC, Y, Ks)),
     member(K,[KP|Ks]), call(K,Y,Ans).

  ~new_soln~(VC, Y, Ks, S1, S2) :-
     rb_upd(VC, tab(Ys1, Ks), tab(Ys2, Ks), S1, S2),
     rb_add(Y, t, Ys1, Ys2).

  ~numbervars_copy~(Work, VC) :-
     copy_term_nat(Work, VC),
     numbervars(VC, 0, _).
\end{prolog-framed}
A few other comments on this code are in order. 
The state of the system is represented as an associative map (using red-black trees)
of variant classes to table entries, each of which contains a set of solutions
(also represented as a red-black tree) and a list of consumer continuations. Each instance
of the state is an \emph{immutable} data structure: only the cell managed by
"run_nb_state/4" is mutable, and its contents are replaced completely on each state
transition. These transitions are managed using the predicates "new_cont/5"
(to decide what to do with the newly captured continuation on each call to a tabled
predicate) and "new_soln/4" (to decide what to do with a new solution from the 
`worker' goal "Work". These two predicates are themselves pure, so that the effectful
operation of changing the state is entirely contained within the "app/2" operator.

The variable "Ans" is used 
to represent the list of `outputs' from the top-level goal initially passed
to "run_tabled/1"; this list is extracted from the goal using "term_variables/2".
Similarly, "Y" represents the `outputs' of a given tabled variant class as a list
of variables, which are eventually bound when solutions are found.

The continuation "Cont" captured when
calling a tabled predicate is a callable term, possibly containing variables shared
with the worker goal, representing `inputs' which are expected to be 
provided by the tabled predicate, and `outputs'
which will be bound when the continuation is called. This continuation is stored
in the table entry for a variant class in the form of a lambda term
"\Y^Ans^Cont" (line 24) so that it can be called as a binary predicate and called multiple times
without binding the variables in the lambda term. Similary, the worker goal 
is passed to "producer/4" in the form of a lambda term "\Y^Work" (line 28),
so that it can be called without binding any of these variables.

\subsection{Program transformation}
While the module "cctable" can be used as-is, by calling tabled goals using the
meta-predicate "cctabled/1", the usual approach to tabling in Prolog is to support a
declaration that a certain predicate should be tabled, such that it can then be
called without any further decoration. This can be achieved using a very shallow
program transformation, similar to that described by \cite{DesouterVan-DoorenSchrijvers2015}.
The implementation is given in the appendix, but result is that the example given 
in \secrf{ccmemo} can be written (now using DCG notation for "path/2") as:
\begin{prolog-framed}
  :- use_module(cctable).
  :- use_module(ccmacros).

  ~path_memo~(Start, End) :- run_tabled(path(Start,End)).

  :- table path/2.
  ~path~ --> edge; path, edge.

  ~edge~(a,b).  ~edge~(a,c).  ~edge~(b,d).  ~edge~(c,d).
\end{prolog-framed}
The "path/2" predicate is transformed via macro expansion on loading to
\begin{prolog}
  ~path~(N1, N2)     :- cctabled(`path#'(N1, N2)).
  `~path#~'(N1, N3) :- edge(N1, N3); path(N1, N2), edge(N2, N3).
\end{prolog}
As well as the DCG translation, the original predicate is renamed by
adding "`#'" to the name, while "path/2" is redirected to a tabled
call of the renamed predicate.


\section{Computational complexity and performance}

The tabling library presented above achieves aim of providing
idiomatic Prolog tabling while consisting almost entirely of pure, declarative Prolog.
Unfortunately, its performance is terrible. This is because maintaining non-backtrackable
state in Prolog requires a certain amount of term copying; not only is this relatively
expensive in itself, it also tends to create more work for the garbage collector. In this case,
because the state is held in a \emph{single} mutable variable, the \emph{entire} state is
copied every on every transition, even if only a small component of the
state has been changed. This creates a tension between the desire for logical purity,
which drives us to minimise the number of points of mutation, and the desire for
efficiency, which drives us to \emph{factorise} the mutable state into several
independently modifiable pieces, so that one component of the state can be modified without
incurring the cost of copying the rest. Thus, at this point, development becomes a 
question of pragmatic balance, attempting to achieve acceptable performance with
a minimal departure from logical purity, which is, perhaps, a little unsatisfying from a 
theoretical point of view, but seems to be unavoidable within the framework
of current Prolog systems. 

\subsection{Complexity analysis}
We can begin to quantify the costs of various copying operations as follows.
Given an application involving tabled predicates, let $N_p$ be the number
of `producer' calls; that is, the number of distinct variant classes in use.
Let $R_c$ be the average number of `consumer' calls per producer; that is, the
number of subsequent calls with a given variant class after the initial
one. Finally, let "R_s" be the average number of solutions per producer.
It is clear that the tabling system must call each continuation for each solution
for each variant class, so that a minimal complexity for a computation that
processes every solution of every tabled call is $O(N_p R_c R_s)$. However,
decisions about to represent the state of the system can incur additional copying costs,
some of which are quadratic in one or more of these metrics. For example, if a piece of
state contains one item for each producer, then copying this state to add a new
producer results in an $O(N_p^2 K)$ cost overall, where $K$ is the size
of the data structure associated with each producer, which may be $O(1)$, $O(R_c)$,
$O(R_s)$ or $O(R_c R_s)$ depending on the representation chosen.
The following table summarises this and other costs that may apply:

\begin{center}
\begin{tabular}{ll}
  \emph{operation} & \emph{cost} \\
  \hline
  1. copying each continuation before calling    & $N_p R_c R_s$ \\
  2. copying each worker to get variant class    & $N_p R_c$ \\
  3. copying all producers to add a new producer & $N_p^2 K $ \\
  % copying producer's worker to avoid binding answer & $N_p$ \\
  4. copying all solutions to add a consumer     & $N_p R_c R_s$ \\
  5. copying all continuations to add a solution & $N_p R_c R_s$ \\
  6. copying all continuations to add a consumer & $N_p R_c^2$ \\
  7. copying all solutions to add a solution     & $N_p R_s^2$ \\
\end{tabular}
\end{center}
%
Of these, the first cannot be avoided, since a single continuation may need to
be called multiple times with different `inputs' in the course of a computation.
The others result from representational choices; for example, (3) applies when
a single term contains information about all producers, which is the case
in the implementation of \secrf{idiomatic}, with $K = R_c R_c$; (6) applies
when all the continuations for a particular producer are stored in a single
data structure, and similarly (7) when all the solutions from a producer are
stored in one term. Indeed, the implementation of \secrf{idiomatic} suffers from
all these costs, in particular the quadratic ones, which explains why it is so slow
on all but the smallest problems.

There are many strategies for reducing or eliminating these copying costs,
several of which are explored in the code repository accompanying this report.
Although a complete description of these is beyond the scope of this report, a few
strategies will be discussed below.

Firstly, it is clear from the table of copying costs that for the optimal asymptotic 
performance of $O(N_p R_c R_s)$ it is most important to avoid costs that are quadratic 
in $N_p$, $R_c$ or $R_s$, as these will eventually dominate in large problems.
The implementation $cctable_db$ does this by using dynamic predicates "producer/1",
"consumer/2" and "solution/2" to acheive a complete factorisation of the state of
the system. Although the overheads associated with using dynamic predicates are larger
than those for non-backtrackable global variables, the asymptotic complexity means
that performance on some of the benchmarks is surprisingly reasonable.

Another way to avoid a quadratic cost of adding solutions is to use the SWI Prolog
"tries" library, which allows a single immutable reference to point to a mutable
associative map. This was introduced to support the tabling library currently included
in SWI Prolog, but is sufficiently general to be used in implementation "cctable_trie", 
for both the map of variant classes to table entries and the set of solutions for each
variant class.

Tries are not a suitable data structure for the collection of continuations associated
with each producer as it is not appropriate to treat them as a set or test them for equality.
Hence, to avoid copying costs quadratic in the number of continuations per producer 
in "cctable_trie", a system of references to growable lists is introduced, built using
the low-level "nb_linkval/2" operation to avoid copying the continuations already in the
list.

While developing approaches to managing the collection of continuations efficiently,
it became clear that size of the continuation terms can be significant factor in some problems, 
most obviously in the implementation of the Fibonacci function, where the total size
of the continuations was found to grow quadratically with the size of the problem.
Discussions with Jan Wielemaker, the principal author of SWI Prolog, lead to the conclusion
that there were two causes of this. Firstly (and most easily dealt with) the inclusion
of the producer's continuation ("KP") as a parameter to "producer/4" meant that continuations
were being included as values in the stack frames as part of other subsequently captured continuations.
This can be avoided by including the producer's continuation in the data structure used
to store the consumers' continuations, rather than passing it as a parameter. As long
as care is taken to keep the producer's continuation at the head of the list, the 
`incremental' property of the system (with solutions being delivered as they are found)
is preserved.

The second cause was that the process of reactivating a continuation which then suspends itself
resulting in a new continuation, which is then reactivated, which then suspends itself,
and so on---results in continuations which gradually accumulate non-operative stack frames.
This lead Jan Wielemaker to introduce optimisations in the low level implementation of 
"shift/1", similar in spirit to \emph{tail call}
optimisations, to remove these stack frames. Coupled with some extra filtering of ineffectual
continuation frames at the Prolog level, this solved the continuation growth problem 
completely, resulting in approximately linear time complexity on the Fibonacci benchmark using
the implementation "cctable_trie_kp".
An equivalent modification was also applied to the dynamic database version 
to get the implementation "cctable_db_kp".

\subsection{An improved implementation}

The implementation "cctable_trie_kp" is given below. Continuations are represented using
the "k/3" functor instead of lambda terms, since copying them in one go (in "lref_get/2") is faster
than copying individually when calling lambda terms. 
\begin{prolog-framed}[name=cctable8,numbers=left]
  :- use_module(library(delimcc), [p_reset/3, p_shift/2]).
  :- use_module(ccnbref, [run_nb_ref/1, nbref_new/2]).
  :- use_module(lambdaki).
        
  :- meta_predicate cctabled(0). 
  ~cctabled~(Head) :- p_shift(tab, Head).

  :- meta_predicate run_tabled(0). 
  ~run_tabled~(Goal) :-
     term_variables(Goal, Ans), trie_new(Trie),
     run_nb_ref(run_tab(Goal, Trie, Ans)),

  ~run_tab~(Goal, Trie, Ans) :-
     p_reset(tab, Goal, Status),
     cont_tab(Status, Trie, Ans).

  ~cont_tab~(done, _, _, _).
  ~cont_tab~(susp(Head, Cont0), Trie, Ans) :-  
     clean_cont(Cont0, Cont),
     term_variables(Head,Y), K = k(Y,Ans,Cont),
     (  trie_lookup(Trie, Head, tab(Solns,Conts))
     -> lref_add(Conts, K),
        trie_gen(Solns, Y, _),
        run_tab(Cont, Trie, Ans)
     ;  lref_new(K, Conts),
        trie_new(Solns),
        trie_insert(Trie, Head, tab(Solns,Conts)),
        run_tab(producer(\Y^Head, Conts, Solns, Ans), Trie, Ans)
     ).

  ~producer~(Generate, Conts, Solns, Ans) :-
     call(Generate, Y),
     trie_insert(Solns, Y, t),
     lref_get(Conts,Ks), member(k(Y,Ans,Cont),Ks),
     call(Cont).

  ~lref_new~(K0, Ref) :- nbref_new([K0], Ref).
  ~lref_get~(Ref, Xs) :- nb_getval(Ref, Ys), copy_term(Ys,Xs).
  ~lref_add~(Ref, K) :- 
    nb_getval(Ref, [K0|Ks]), duplicate_term(K,K1), 
    nb_linkval(Ref, [K0,K1|Ks]).
\end{prolog-framed}

\subsection{Benchmarks}

Several of the implementation variations described above were tested on a selection
of the benchmarks that were used by \cite{DesouterVan-DoorenSchrijvers2015} and
compared with alternative tabling implementations. Two of these run in SWI Prolog:
"desouter-pl" is \citepos{DesouterVan-DoorenSchrijvers2015} original tabling library
ported from hProlog to SWI Prolog (available at \url{https://github/JanWielemaker/tabling_library}),
and "desouter-plc" is the optimised version of this, with some components re-implemented
in C for greater speed. In addition, the tabling implementations in two other Prologs,
YAP and B-Prolog ("bp") were also tested, though it should be noted that these are both
much faster Prologs in general and that in both tabling is implemented at a low level.
The benchmarks themselves were derived from code available at \url{https://github/JanWielemaker/tabling_benchmarks}.

[B-Prolog uses linear tabling, which is very fast in some problems but much slower in others.]

[YAP doesn't support arbitrary precision arithmetic, so it cannot run the Fibonacci benchmark
at the required sizes.]

[The naive reverse benchmark doesn't actually benefit from tabling at all, as no call is
ever made more than once. Thus, it measures the minimal overhead introduced by tabling.]

\begin{figure}
  \begin{center}
    \begin{tabular}{@{}c@{}c@{}}
      \colfig[0.5]{fib(1000)}
    & \colfig[0.5]{nrev(1000)}
    \\
      \colfig[0.5]{shuttle(2000)}
    & \colfig[0.5]{ping_pong(10000)}
    \\
      \colfig[0.5]{recognise(20000)}
    & \colfig[0.5]{monoidal}
  \end{tabular}
  \end{center}
  \caption{Performance of several tabling implementations on a subset of benchmarks. The horizontal
  axis is the reciprocal of the execution time in seconds, and so longer bars represent faster
  performance. The timings for YAP have been excluded as they are in almost all cases the fastest.
  \figlab{speed}}
\end{figure}

\section{Discussion and conclusions}

The implementation presented in this report was largely derived from the OCaml
version reported by \cite{Abdallah2017a}, but it shares many similarities with
the tabling library of \cite{DesouterVan-DoorenSchrijvers2015}; for example,
the use of "numbervars/3" to represent variant classes as ground terms. In
addition, the drive for acceptable asymptotic performance lead to the adoption
of mutable tries for mananging both the collection of variant classes and the sets
of solutions for each variant class.

However, there are several significant differences.
The control structure and scheduling mechanism is more declarative, with less
reliance on side effects. In terms of the amount of code it is much simpler.
It delivering solutions incrementally, rather than having to collect them all before 
delivering the first one.

[Observations on performance?]

[Importance of minimising copying?]

[Future work: faster implementation of list of continuations, analogous to `worklists' in
"desouter-plc" implementation.

\appendix
\section{Supporting code}

Modules "lambdaki", "ccstate" and "delimcc" can be found in the SWI Prolog
add-on package "genutils", which can be installed in SWI Prolog with the command
"pack_install(genutils)". The rest of the code presented in this report can be
found at \url{https://github.com/samer--/cctable}.

\subsection{Lambda abstractions}
\label{sec:lambdaki}

This module is a minimal implementation of lambda terms, which are callable terms representing
predicates taking one or more arguments, which can be useful for high-order programming and
reducing the need to define trivial auxillary predicates. It is a simplified version of 
\citepos{Neumerkel2009} "lambda" library,
supporting only unary and binary application with no free variables.

\begin{prolog-framed}[name=lambdaki]
  :- module(lambdaki, [(\)/2, (\)/3, (^)/3, (^)/4]).

  :- meta_predicate \(1,?), \(2,?,?).
  :- meta_predicate ^(?,0,?), ^(?,1,?,?).

  ~\~(M:Hats, A1)     :- copy_term(Hats, Copy), call(M:Copy, A1).
  ~\~(M:Hats, A1, A2) :- copy_term(Hats, Copy), call(M:Copy, A1, A2).

  ~^~(A1, P, A1)     :- call(P).
  ~^~(A1, P, A1, A2) :- call(P, A2).
\end{prolog-framed}

\subsection{Non-backtrackable mutable state}
\label{app:ccnbstate}

The module "ccnbstate" implements a delimited context "run_nb_state/4"
providing one piece of non-backtrackable mutable state, which can be modified with any binary predicate
using "app/2" or retrieved using "get/2". The global variable used to store the state
is protected from accidental interference and is destroyed when the stateful
computation is finished. This code is included in the module "ccstate", which 
is part of the SWI Prolog add-on package "genutils".
\begin{prolog-framed}[name=ccnbstate]
  :- module(ccnbstate, [run_nb_state/4, app/2, get/2]).
  :- use_module(library(delimcc)).

  :- meta_predicate app(+,2).
  ~app~(Pr,P) :- p_shift(Pr, app(P)).
  ~get~(Pr,P) :- p_shift(Pr, get(P)).

  :- meta_predicate run_nb_state(+,0,+,-).
  ~run_nb_state~(Pr, Goal, S1, S2) :-
     gensym(nbs,K),
     setup_call_cleanup( nb_setval(K, S1),
                         (run(Pr, Goal, K), nb_getval(K, S2)),
                         nb_delete(K)).

  ~run~(Pr, Goal, K) :- p_reset(Pr, Goal, Status), cont(Status, Pr, K).

  ~cont~(susp(R,Cont), Pr, K) :- handle(R,K), run(Pr, Cont, K).
  ~cont~(done, _, _).

  ~handle~(get(S),K) :- nb_getval(K,S).
  ~handle~(app(P),K) :- nb_getval(K,S1), call(P,S1,S2), nb_setval(K,S2).
\end{prolog-framed}

\subsection{Program transformation}
\label{sec:ccmacros}

The module "ccmaros" implements a shallow program transformation to support
tabling. Predicates decalared `tabled' are renamed (using the special
SWI Prolog hook "prolog:rename_predicate/2" to appendng
a "`#'" to their given name) and the original predicate name defined
as a metacall of the renamed predicate via cctable/1, which is 
assumed to be available in the module where the tabled precicate
is defined. 

\begin{prolog-framed}[name=ccmacros,label=lst:ccmacros]
  :- module(ccmacros, [op(1150, fx, table)]).
  :- op(1150, fx, table).

  ~system:term_expansion~((:- table(Specs)), Clauses) :- 
     foldl_clist(expand_cctab, Specs, Clauses, []).

  ~foldl_clist~(P,(A,B)) --> !, call(P,A), foldl_clist(P,B).
  ~foldl_clist~(P,A)     --> call(P,A).

  ~prolog:rename_predicate~(M:Head, M:Worker) :-
     `&flushed_predicate'(M:`&cctabled'(_)),
     call(M:`&cctabled'(Head)), !,
     head_worker(Head, Worker).

  ~expand_cctab~(Name//Arity) --> !, 
     {A2 is Arity+2}, 
     expand_cctab(Name/A2).

  ~expand_cctab~(Name/Arity) --> 
     { functor(Head, Name, Arity), head_worker(Head, Worker)},
     [ (:- discontiguous(`&cctabled'/1))
     , `&cctabled'(Head)
     , (Head :- cctabled(Worker))
     ]. 

  ~head_worker~(Head, Worker) :-
    Head   =.. [H|As], atom_concat(H, `#', W),
    Worker =.. [W|As].
\end{prolog-framed}

% vim: ts=2 sw=2 expandtab
